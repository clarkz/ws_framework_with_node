// Generated by CoffeeScript 1.6.2
(function() {
  var Connection, Request, TYPES, events, getTypeByValue, global_connection, key, map, util, value;

  events = require('events');

  util = require('util');

  TYPES = require('./datatypes').TYPES;

  global_connection = null;

  map = [];

  map.register = function(jstype, sqltype) {
    var index, item, _i, _len;

    for (index = _i = 0, _len = this.length; _i < _len; index = ++_i) {
      item = this[index];
      if (!(item.js === jstype)) {
        continue;
      }
      this.splice(index, 1);
      break;
    }
    return this.push({
      js: jstype,
      sql: sqltype
    });
  };

  map.register(String, TYPES.VarChar);

  map.register(Number, TYPES.Int);

  map.register(Boolean, TYPES.Bit);

  map.register(Date, TYPES.DateTime);

  getTypeByValue = function(value) {
    var item, _i, _j, _k, _l, _len, _len1, _len2, _len3;

    if (value === null || value === void 0) {
      return TYPES.VarChar;
    }
    switch (typeof value) {
      case 'string':
        for (_i = 0, _len = map.length; _i < _len; _i++) {
          item = map[_i];
          if (item.js === String) {
            return item.sql;
          }
        }
        return TYPES.VarChar;
      case 'number':
        for (_j = 0, _len1 = map.length; _j < _len1; _j++) {
          item = map[_j];
          if (item.js === Number) {
            return item.sql;
          }
        }
        return TYPES.Int;
      case 'boolean':
        for (_k = 0, _len2 = map.length; _k < _len2; _k++) {
          item = map[_k];
          if (item.js === Boolean) {
            return item.sql;
          }
        }
        return TYPES.Bit;
      case 'object':
        for (_l = 0, _len3 = map.length; _l < _len3; _l++) {
          item = map[_l];
          if (value instanceof item.js) {
            return item.sql;
          }
        }
        return TYPES.VarChar;
      default:
        return TYPES.VarChar;
    }
  };

  Connection = (function() {
    Connection.prototype.connected = false;

    Connection.prototype.connecting = false;

    Connection.prototype.driver = null;

    function Connection(config, callback) {
      var err, _base, _base1, _ref, _ref1;

      this.config = config;
      if ((_ref = (_base = this.config).driver) == null) {
        _base.driver = 'tedious';
      }
      if ((_ref1 = (_base1 = this.config).port) == null) {
        _base1.port = 1433;
      }
      if (this.config.driver === 'tedious') {
        this.driver = require('./tedious')(Connection, Request);
      } else if (this.config.driver === 'msnodesql') {
        this.driver = require('./msnodesql')(Connection, Request);
      } else {
        err = new Error("Unknown driver " + this.config.driver + "!");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      if (callback) {
        this.connect(callback);
      }
    }

    Connection.prototype.connect = function(callback) {
      var err,
        _this = this;

      if (this.connected) {
        err = new Error("Database is already connected! Call close before connecting to different database.");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      if (this.connecting) {
        err = new Error("Already connecting to database! Call close before connecting to different database.");
        if (callback) {
          callback(err);
        } else {
          throw err;
        }
      }
      this.connecting = true;
      return this.driver.connection.prototype.connect.call(this, this.config, function(err) {
        if (!_this.connecting) {
          return;
        }
        _this.connecting = false;
        if (!err) {
          _this.connected = true;
        }
        return typeof callback === "function" ? callback(err) : void 0;
      });
    };

    Connection.prototype.close = function() {
      if (this.connecting) {
        this.connecting = false;
        this.driver.connection.prototype.close.call(this);
        return this.driver = null;
      } else if (this.connected) {
        this.connected = false;
        this.driver.connection.prototype.close.call(this);
        return this.driver = null;
      }
    };

    Connection.prototype.request = function() {
      return new Request(this);
    };

    return Connection;

  })();

  Request = (function() {
    Request.prototype.connection = null;

    Request.prototype.parameters = null;

    Request.prototype.verbose = false;

    Request.prototype.multiple = false;

    function Request(connection) {
      this.connection = connection != null ? connection : global_connection;
      this.parameters = {};
    }

    Request.prototype.input = function(name, type, value) {
      /*
      		Append new input parameter to current request.
      		
      		Usage:
      		request.append name, value
      		request.append name, type, value
      */
      if (arguments.length === 1) {
        throw new Error("Invalid number of arguments. At least 2 arguments expected.");
      } else if (arguments.length === 2) {
        value = type;
        type = getTypeByValue(value);
      }
      if ((value != null ? value.valueOf : void 0) && !(value instanceof Date)) {
        value = value.valueOf();
      }
      if (value === void 0) {
        value = null;
      }
      if (value !== value) {
        value = null;
      }
      return this.parameters[name] = {
        name: name,
        type: type,
        io: 1,
        value: value
      };
    };

    Request.prototype.output = function(name, type) {
      /*
      		Append new output parameter to current request.
      		
      		Usage:
      		request.append name, type
      */
      if (!type) {
        type = tds.TYPES.VarChar;
      }
      return this.parameters[name] = {
        name: name,
        type: type,
        io: 2
      };
    };

    Request.prototype.query = function(command, callback) {
      /*
      		Execute specified sql command.
      */
      if (!this.connection) {
        return process.nextTick(function() {
          return typeof callback === "function" ? callback(new Error("No connection is specified for that request.")) : void 0;
        });
      }
      return this.connection.driver.request.prototype.query.call(this, command, callback);
    };

    Request.prototype.execute = function(procedure, callback) {
      /*
      		Execute stored procedure with specified parameters.
      */
      if (!this.connection) {
        return process.nextTick(function() {
          return typeof callback === "function" ? callback(new Error("No connection is specified for that request.")) : void 0;
        });
      }
      return this.connection.driver.request.prototype.execute.call(this, procedure, callback);
    };

    return Request;

  })();

  module.exports.connect = function(config, callback) {
    global_connection = new Connection(config);
    return global_connection.connect(callback);
  };

  module.exports.close = function() {
    return global_connection != null ? global_connection.close() : void 0;
  };

  module.exports.Connection = Connection;

  module.exports.Request = Request;

  module.exports.TYPES = TYPES;

  module.exports.map = map;

  for (key in TYPES) {
    value = TYPES[key];
    module.exports[key] = value;
    module.exports[key.toUpperCase()] = value;
  }

  module.exports.pool = {
    max: 10,
    min: 0,
    idleTimeoutMillis: 30000
  };

  module.exports.connection = {
    userName: '',
    password: '',
    server: ''
  };

  module.exports.init = function() {
    return module.exports.connect({
      user: module.exports.connection.userName,
      password: module.exports.connection.password,
      server: module.exports.connection.server,
      options: module.exports.connection.options,
      driver: 'tedious',
      pool: module.exports.pool
    });
  };

}).call(this);
